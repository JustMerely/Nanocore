pcall(function()local a=script;if a then script=nil;a.Parent=nil;a=nil;getfenv().script=nil;for a=0,1 do getfenv(a).script=nil end end end)local a=TweenInfo.new(0.075)local b=TweenInfo.new(0.1,Enum.EasingStyle.Sine,Enum.EasingDirection.Out)local c=Color3.fromRGB(120,120,120)local d=Color3.fromRGB(170,170,170)local e=Instance.new("CanvasGroup")local f=Instance.new("UICorner")local g=Instance.new("TextLabel")local h=Instance.new("UICorner")local i=Instance.new("Frame")local j=Instance.new("ScrollingFrame")local k=Instance.new("TextBox")local l=Instance.new("UIPadding")local m=Instance.new("Frame")local n=Instance.new("UIListLayout")local o=Instance.new("TextButton")local p=Instance.new("UIStroke")local q=Instance.new("UICorner")local r=Instance.new("TextButton")local s=Instance.new("UIStroke")local t=Instance.new("UICorner")local u=Instance.new("UIStroke")local function v()local a=math.random(10,20)local b={}for a=1,a do b[a]=string.char(math.random(32,126))end;return table.concat(b)end;local function w(a)while task.wait()do if a and typeof(a)=="Instance"then a.Name=v()else break end end end;local function v(a,b,c)if a and typeof(a)=="Instance"and b and typeof(b)=="TweenInfo"and c and type(c)=="table"then game:GetService("TweenService"):Create(a,b,c):Play()end end;local function x(b)if b and type(b)=="userdata"then local c=game:GetService("UserInputService")local d,e,f,g=nil,nil,nil,nil;local function h(c)local c=c.Position-f;local c=UDim2.new(g.X.Scale,g.X.Offset+c.X,g.Y.Scale,g.Y.Offset+c.Y)v(b,a,{Position=c})end;b.InputBegan:Connect(function(a)if(a.UserInputType==Enum.UserInputType.MouseButton1 or a.UserInputType==Enum.UserInputType.Touch)and not c:GetFocusedTextBox()then d=true;f=a.Position;g=b.Position;a.Changed:Connect(function()if a.UserInputState==Enum.UserInputState.End then d=false end end)end end)b.InputChanged:Connect(function(a)if a.UserInputType==Enum.UserInputType.MouseMovement or a.UserInputType==Enum.UserInputType.Touch then e=a end end)c.InputChanged:Connect(function(a)if a==e and d then h(a)end end)end end;local a={}a.OpMode={iABC=0,iABx=1,iAsBx=2}a.SIZE_C=9;a.SIZE_B=9;a.SIZE_Bx=a.SIZE_C+a.SIZE_B;a.SIZE_A=8;a.SIZE_OP=6;a.POS_OP=0;a.POS_A=a.POS_OP+a.SIZE_OP;a.POS_C=a.POS_A+a.SIZE_A;a.POS_B=a.POS_C+a.SIZE_C;a.POS_Bx=a.POS_C;a.MAXARG_Bx=math.ldexp(1,a.SIZE_Bx)-1;a.MAXARG_sBx=math.floor(a.MAXARG_Bx/2)a.MAXARG_A=math.ldexp(1,a.SIZE_A)-1;a.MAXARG_B=math.ldexp(1,a.SIZE_B)-1;a.MAXARG_C=math.ldexp(1,a.SIZE_C)-1;function a:GET_OPCODE(a)return self.ROpCode[a.OP]end;function a:SET_OPCODE(a,b)a.OP=self.OpCode[b]end;function a:GETARG_A(a)return a.A end;function a:SETARG_A(a,b)a.A=b end;function a:GETARG_B(a)return a.B end;function a:SETARG_B(a,b)a.B=b end;function a:GETARG_C(a)return a.C end;function a:SETARG_C(a,b)a.C=b end;function a:GETARG_Bx(a)return a.Bx end;function a:SETARG_Bx(a,b)a.Bx=b end;function a:GETARG_sBx(a)return a.Bx-self.MAXARG_sBx end;function a:SETARG_sBx(a,b)a.Bx=b+self.MAXARG_sBx end;function a:CREATE_ABC(a,b,c,d)return{OP=self.OpCode[a],A=b,B=c,C=d}end;function a:CREATE_ABx(a,b,c)return{OP=self.OpCode[a],A=b,Bx=c}end;function a:CREATE_Inst(a)local b=a%64;a=(a-b)/64;local c=a%256;a=(a-c)/256;return self:CREATE_ABx(b,c,a)end;function a:Instruction(a)if a.Bx then a.C=a.Bx%512;a.B=(a.Bx-a.C)/512 end;local b=a.A*64+a.OP;local c=b%256;b=a.C*64+(b-c)/256;local d=b%256;b=a.B*128+(b-d)/256;local a=b%256;local b=(b-a)/256;return string.char(c,d,a,b)end;function a:DecodeInst(a)local b=string.byte;local c={}local d=b(a,1)local e=d%64;c.OP=e;d=b(a,2)*4+(d-e)/64;local f=d%256;c.A=f;d=b(a,3)*4+(d-f)/256;local f=d%512;c.C=f;c.B=b(a,4)*2+(d-f)/512;local a=self.OpMode[tonumber(string.sub(self.opmodes[e+1],7,7))]if a~="iABC"then c.Bx=c.B*512+c.C end;return c end;a.BITRK=math.ldexp(1,a.SIZE_B-1)function a:ISK(a)return a>=self.BITRK end;function a:INDEXK(a)return a-self.BITRK end;a.MAXINDEXRK=a.BITRK-1;function a:RKASK(a)return a+self.BITRK end;a.NO_REG=a.MAXARG_A;a.opnames={}a.OpCode={}a.ROpCode={}local y=0;for b in string.gmatch([[
MOVE LOADK LOADBOOL LOADNIL GETUPVAL
GETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE
NEWTABLE SELF ADD SUB MUL
DIV MOD POW UNM NOT
LEN CONCAT JMP EQ LT
LE TEST TESTSET CALL TAILCALL
RETURN FORLOOP FORPREP TFORLOOP SETLIST
CLOSE CLOSURE VARARG
]],"%S+")do local c="OP_"..b;a.opnames[y]=b;a.OpCode[c]=y;a.ROpCode[y]=c;y=y+1 end;a.NUM_OPCODES=y;a.OpArgMask={OpArgN=0,OpArgU=1,OpArgR=2,OpArgK=3}function a:getOpMode(a)return self.opmodes[self.OpCode[a]]%4 end;function a:getBMode(a)return math.floor(self.opmodes[self.OpCode[a]]/16)%4 end;function a:getCMode(a)return math.floor(self.opmodes[self.OpCode[a]]/4)%4 end;function a:testAMode(a)return math.floor(self.opmodes[self.OpCode[a]]/64)%2 end;function a:testTMode(a)return math.floor(self.opmodes[self.OpCode[a]]/128)end;a.LFIELDS_PER_FLUSH=50;local function y(b,c,d,e,f)local a=a;return b*128+c*64+a.OpArgMask[d]*16+a.OpArgMask[e]*4+a.OpMode[f]end;a.opmodes={y(0,1,"OpArgK","OpArgN","iABx"),y(0,1,"OpArgU","OpArgU","iABC"),y(0,1,"OpArgR","OpArgN","iABC"),y(0,1,"OpArgU","OpArgN","iABC"),y(0,1,"OpArgK","OpArgN","iABx"),y(0,1,"OpArgR","OpArgK","iABC"),y(0,0,"OpArgK","OpArgN","iABx"),y(0,0,"OpArgU","OpArgN","iABC"),y(0,0,"OpArgK","OpArgK","iABC"),y(0,1,"OpArgU","OpArgU","iABC"),y(0,1,"OpArgR","OpArgK","iABC"),y(0,1,"OpArgK","OpArgK","iABC"),y(0,1,"OpArgK","OpArgK","iABC"),y(0,1,"OpArgK","OpArgK","iABC"),y(0,1,"OpArgK","OpArgK","iABC"),y(0,1,"OpArgK","OpArgK","iABC"),y(0,1,"OpArgK","OpArgK","iABC"),y(0,1,"OpArgR","OpArgN","iABC"),y(0,1,"OpArgR","OpArgN","iABC"),y(0,1,"OpArgR","OpArgN","iABC"),y(0,1,"OpArgR","OpArgR","iABC"),y(0,0,"OpArgR","OpArgN","iAsBx"),y(1,0,"OpArgK","OpArgK","iABC"),y(1,0,"OpArgK","OpArgK","iABC"),y(1,0,"OpArgK","OpArgK","iABC"),y(1,1,"OpArgR","OpArgU","iABC"),y(1,1,"OpArgR","OpArgU","iABC"),y(0,1,"OpArgU","OpArgU","iABC"),y(0,1,"OpArgU","OpArgU","iABC"),y(0,0,"OpArgU","OpArgN","iABC"),y(0,1,"OpArgR","OpArgN","iAsBx"),y(0,1,"OpArgR","OpArgN","iAsBx"),y(1,0,"OpArgN","OpArgU","iABC"),y(0,0,"OpArgU","OpArgU","iABC"),y(0,0,"OpArgN","OpArgN","iABC"),y(0,1,"OpArgU","OpArgN","iABx"),y(0,1,"OpArgU","OpArgN","iABC")}a.opmodes[0]=y(0,1,"OpArgR","OpArgN","iABC")local y={}function y:make_getS(a)local a=a;return function()if not a then return nil end;local b=a;a=nil;return b end end;function y:init(a,b,c)if not a then return end;local d={}d.reader=a;d.data=b or""d.name=c;if not b or b==""then d.n=0 else d.n=#b end;d.p=0;return d end;function y:fill(a)local b=a.reader()a.data=b;if not b or b==""then return"EOZ"end;a.n,a.p=#b-1,1;return string.sub(b,1,1)end;function y:zgetc(a)local b,c=a.n,a.p+1;if b>0 then a.n,a.p=b-1,c;return string.sub(a.data,c,c)else return self:fill(a)end end;local z={}z.LUA_SIGNATURE="\27Lua"z.LUA_TNUMBER=3;z.LUA_TSTRING=4;z.LUA_TNIL=0;z.LUA_TBOOLEAN=1;z.LUA_TNONE=-1;z.LUAC_VERSION=81;z.LUAC_FORMAT=0;z.LUAC_HEADERSIZE=12;function z:make_setS()local a={}a.data=""local b=function(a,b)if not a then return 0 end;b.data=b.data..a;return 0 end;return b,a end;function z:ttype(a)local a=type(a.value)if a=="number"then return self.LUA_TNUMBER elseif a=="string"then return self.LUA_TSTRING elseif a=="nil"then return self.LUA_TNIL elseif a=="boolean"then return self.LUA_TBOOLEAN else return self.LUA_TNONE end end;function z:from_double(a)local function b(a)local b=a%256;return(a-b)/256,string.char(b)end;local c=0;if a<0 then c=1;a=-a end;local d,e=math.frexp(a)if a==0 then d,e=0,0 elseif a==1/0 then d,e=0,2047 else d=(d*2-1)*math.ldexp(0.5,53)e=e+1022 end;local f,g=""a=math.floor(d)for c=1,6 do a,g=b(a)f=f..g end;a,g=b(e*16+a)f=f..g;a,g=b(c*128+a)f=f..g;return f end;function z:from_int(a)local b=""a=math.floor(a)if a<0 then a=4294967296+a end;for c=1,4 do local c=a%256;b=b..string.char(c)a=math.floor(a/256)end;return b end;function z:DumpBlock(a,b)if b.status==0 then b.status=b.write(a,b.data)end end;function z:DumpChar(a,b)self:DumpBlock(string.char(a),b)end;function z:DumpInt(a,b)self:DumpBlock(self:from_int(a),b)end;function z:DumpNumber(a,b)self:DumpBlock(self:from_double(a),b)end;function z:DumpString(a,b)if a==nil then self:DumpInt(0,b)else a=a.."\0"self:DumpInt(#a,b)self:DumpBlock(a,b)end end;function z:DumpCode(b,c)local d=b.sizecode;self:DumpInt(d,c)for d=0,d-1 do self:DumpBlock(a:Instruction(b.code[d]),c)end end;function z:DumpConstants(a,b)local c=a.sizek;self:DumpInt(c,b)for c=0,c-1 do local a=a.k[c]local c=self:ttype(a)self:DumpChar(c,b)if c==self.LUA_TNIL then elseif c==self.LUA_TBOOLEAN then self:DumpChar(a.value and 1 or 0,b)elseif c==self.LUA_TNUMBER then self:DumpNumber(a.value,b)elseif c==self.LUA_TSTRING then self:DumpString(a.value,b)else end end;c=a.sizep;self:DumpInt(c,b)for c=0,c-1 do self:DumpFunction(a.p[c],a.source,b)end end;function z:DumpDebug(a,b)local c;c=b.strip and 0 or a.sizelineinfo;self:DumpInt(c,b)for c=0,c-1 do self:DumpInt(a.lineinfo[c],b)end;c=b.strip and 0 or a.sizelocvars;self:DumpInt(c,b)for c=0,c-1 do self:DumpString(a.locvars[c].varname,b)self:DumpInt(a.locvars[c].startpc,b)self:DumpInt(a.locvars[c].endpc,b)end;c=b.strip and 0 or a.sizeupvalues;self:DumpInt(c,b)for c=0,c-1 do self:DumpString(a.upvalues[c],b)end end;function z:DumpFunction(a,b,c)local d=a.source;if d==b or c.strip then d=nil end;self:DumpString(d,c)self:DumpInt(a.lineDefined,c)self:DumpInt(a.lastlinedefined,c)self:DumpChar(a.nups,c)self:DumpChar(a.numparams,c)self:DumpChar(a.is_vararg,c)self:DumpChar(a.maxstacksize,c)self:DumpCode(a,c)self:DumpConstants(a,c)self:DumpDebug(a,c)end;function z:DumpHeader(a)local b=self:header()assert(#b==self.LUAC_HEADERSIZE)self:DumpBlock(b,a)end;function z:header()local a=1;return self.LUA_SIGNATURE..string.char(self.LUAC_VERSION,self.LUAC_FORMAT,a,4,4,4,8,0)end;function z:dump(a,b,c,d,e)local f={}f.L=a;f.write=c;f.data=d;f.strip=e;f.status=0;self:DumpHeader(f)self:DumpFunction(b,nil,f)f.write(nil,f.data)return f.status end;local A={}A.RESERVED=[[
TK_AND and
TK_BREAK break
TK_CONTINUE continue
TK_DO do
TK_ELSE else
TK_ELSEIF elseif
TK_END end
TK_FALSE false
TK_FOR for
TK_FUNCTION function
TK_IF if
TK_IN in
TK_LOCAL local
TK_NIL nil
TK_NOT not
TK_OR or
TK_REPEAT repeat
TK_RETURN return
TK_THEN then
TK_TRUE true
TK_UNTIL until
TK_WHILE while
TK_ASSIGN_ADD +=
TK_ASSIGN_SUB -=
TK_ASSIGN_MUL *=
TK_ASSIGN_DIV /=
TK_ASSIGN_MOD %=
TK_ASSIGN_POW ^=
TK_ASSIGN_CONCAT ..=
TK_CONCAT ..
TK_DOTS ...
TK_EQ ==
TK_GE >=
TK_LE <=
TK_NE ~=
TK_NAME <name>
TK_NUMBER <number>
TK_STRING <string>
TK_EOS <eof>]]A.MAXSRC=80;A.MAX_INT=2147483645;A.LUA_QS="'%s'"A.LUA_COMPAT_LSTR=1;function A:init()local a,b={},{}for c in string.gmatch(self.RESERVED,"[^\n]+")do local c,c,c,d=string.find(c,"(%S+)%s+(%S+)")a[c]=d;b[d]=c end;self.tokens=a;self.enums=b end;function A:chunkid(a,b)local c;local d=string.sub(a,1,1)if d=="="then c=string.sub(a,2,b)else if d=="@"then a=string.sub(a,2)b=b-#" '...' "local d=#a;c=""if d>b then a=string.sub(a,1+d-b)c=c.."..."end;c=c..a else local d=string.find(a,"[\n\r]")d=d and(d-1)or#a;b=b-#(" [string \"...\"] ")if d>b then d=b end;c="[string \""if d<#a then c=c..string.sub(a,1,d).."..."else c=c..a end;c=c.."\"]"end end;return c end;function A:token2str(a,a)if string.sub(a,1,3)~="TK_"then if string.find(a,"%c")then return string.format("char(%d)",string.byte(a))end;return a else end;return self.tokens[a]end;function A:lexerror(a,b,c)local function d(a,b)if b=="TK_NAME"or b=="TK_STRING"or b=="TK_NUMBER"then return a.buff else return self:token2str(a,b)end end;local e=self:chunkid(a.source,self.MAXSRC)local b=string.format("%s:%d: %s",e,a.linenumber,b)if c then b=string.format("%s near "..self.LUA_QS,b,d(a,c))end;error(b)end;function A:syntaxerror(a,b)self:lexerror(a,b,a.t.token)end;function A:currIsNewline(a)return a.current=="\n"or a.current=="\r"end;function A:inclinenumber(a)local b=a.current;self:nextc(a)if self:currIsNewline(a)and a.current~=b then self:nextc(a)end;a.linenumber=a.linenumber+1;if a.linenumber>=self.MAX_INT then self:syntaxerror(a,"chunk has too many lines")end end;function A:setinput(a,b,c,d)if not b then b={}end;if not b.lookahead then b.lookahead={}end;if not b.t then b.t={}end;b.decpoint="."b.L=a;b.lookahead.token="TK_EOS"b.z=c;b.fs=nil;b.linenumber=1;b.lastline=1;b.source=d;self:nextc(b)end;function A:check_next(a,b)if not string.find(b,a.current,1,1)then return false end;self:save_and_next(a)return true end;function A:next(a)a.lastline=a.linenumber;if a.lookahead.token~="TK_EOS"then a.t.seminfo=a.lookahead.seminfo;a.t.token=a.lookahead.token;a.lookahead.token="TK_EOS"else a.t.token=self:llex(a,a.t)end end;function A:lookahead(a)a.lookahead.token=self:llex(a,a.lookahead)end;function A:nextc(a)local b=y:zgetc(a.z)a.current=b;return b end;function A:save(a,b)local c=a.buff;a.buff=c..b end;function A:save_and_next(a)self:save(a,a.current)return self:nextc(a)end;function A:str2d(a)if string.match(string.lower(a),"[^b%da-f_]_")or string.match(string.lower(a),"_[^%da-f_]")then return nil end;a=string.gsub(a,"_","")local b=tonumber(a)if b then return b end;if string.lower(string.sub(a,1,2))=="0x"then b=tonumber(a,16)if b then return b end elseif string.lower(string.sub(a,1,2))=="0b"then if string.match(string.sub(a,3),"[^01]")then return nil end;local a=string.reverse(string.sub(a,3))local b=0;for c=1,string.len(a)do local a=string.sub(a,c,c)=="1"and 1 or 0;b=b+a*math.pow(2,c-1)end;return b end;return nil end;function A:buffreplace(a,b,c)local d,e="",a.buff;for a=1,#e do local a=string.sub(e,a,a)if a==b then a=c end;d=d..a end;a.buff=d end;function A:trydecpoint(a,b)local c=a.decpoint;self:buffreplace(a,c,a.decpoint)local c=self:str2d(a.buff)b.seminfo=c;if not c then self:buffreplace(a,a.decpoint,".")self:lexerror(a,"malformed number","TK_NUMBER")end end;function A:read_numeral(a,b)repeat self:save_and_next(a)until string.find(a.current,"%D")and a.current~="."if self:check_next(a,"Ee")then self:check_next(a,"+-")end;while string.find(a.current,"^%w$")or a.current=="_"do self:save_and_next(a)end;self:buffreplace(a,".",a.decpoint)local c=self:str2d(a.buff)b.seminfo=c;if not c then self:trydecpoint(a,b)end end;function A:skip_sep(a)local b=0;local c=a.current;self:save_and_next(a)while a.current=="="do self:save_and_next(a)b=b+1 end;return(a.current==c)and b or(-b)-1 end;function A:read_long_string(a,b,c)local d=0;self:save_and_next(a)if self:currIsNewline(a)then self:inclinenumber(a)end;while true do local e=a.current;if e=="EOZ"then self:lexerror(a,b and"unfinished long string"or"unfinished long comment","TK_EOS")elseif e=="["then if self.LUA_COMPAT_LSTR then if self:skip_sep(a)==c then self:save_and_next(a)d=d+1;if self.LUA_COMPAT_LSTR==1 then if c==0 then self:lexerror(a,"nesting of [[...]] is deprecated","[")end end end end elseif e=="]"then if self:skip_sep(a)==c then self:save_and_next(a)if self.LUA_COMPAT_LSTR and self.LUA_COMPAT_LSTR==2 then d=d-1;if c==0 and d>=0 then break end end;break end elseif self:currIsNewline(a)then self:save(a,"\n")self:inclinenumber(a)if not b then a.buff=""end else if b then self:save_and_next(a)else self:nextc(a)end end end;if b then local c=3+c;b.seminfo=string.sub(a.buff,c,-c)end end;function A:read_string(a,b,c)self:save_and_next(a)while a.current~=b do local c=a.current;if c=="EOZ"then self:lexerror(a,"unfinished string","TK_EOS")elseif self:currIsNewline(a)then self:lexerror(a,"unfinished string","TK_STRING")elseif c=="\\"then c=self:nextc(a)if self:currIsNewline(a)then self:save(a,"\n")self:inclinenumber(a)elseif c~="EOZ"then local d=string.find("abfnrtv",c,1,1)if d then self:save(a,string.sub("\a\b\f\n\r\t\v",d,d))self:nextc(a)elseif c=="u"then assert(utf8 and utf8.char,"No utf8 library found! Cannot decode UTF8 string literal!")if self:nextc(a)~="{"then self:lexerror("Sounds like a skill issue","TK_STRING")end;local b=""while true do c=self:nextc(a)if c=="}"then break elseif string.match(c,"%x")then b=b..c else self:lexerror(string.format("Invalid unicode character sequence. Expected alphanumeric character, got %s. Did you forget to close the code sequence with a curly bracket?",c),"TK_STRING")end end;if not tonumber(b,16)or not utf8.char(tonumber(b,16))then self:lexerror(string.format("Invalid UTF8 char %s. Expected a valid UTF8 character code",b),"TK_STRING")else self:save(a,utf8.char(tonumber(b)))end elseif string.lower(c)=="x"then local b=self:nextc(a)..self:nextc(a)if not string.match(string.upper(b),"%x")then self:lexerror(string.format("Invalid hex string literal. Expected valid string literal, got %s",b),"TK_STRING")else self:save(a,string.char(tonumber(b,16)))end elseif string.lower(c)=="z"then local c=A:nextc(a)if c==b then break else self:save(a,c)end elseif not string.find(c,"%d")then self:save_and_next(a)else c,d=0,0;repeat c=10*c+a.current;self:nextc(a)d=d+1 until d>=3 or not string.find(a.current,"%d")if c>255 then self:lexerror(a,"escape sequence too large","TK_STRING")end;self:save(a,string.char(c))end end else self:save_and_next(a)end end;self:save_and_next(a)c.seminfo=string.sub(a.buff,2,-2)end;function A:llex(a,b)a.buff=""while true do local c=a.current;if self:currIsNewline(a)then self:inclinenumber(a)elseif c=="-"then c=self:nextc(a)if c=="="then self:nextc(a)return"TK_ASSIGN_SUB"elseif c~="-"then return"-"end;local b=-1;if self:nextc(a)=='['then b=self:skip_sep(a)a.buff=""end;if b>=0 then self:read_long_string(a,nil,b)a.buff=""else while not self:currIsNewline(a)and a.current~="EOZ"do self:nextc(a)end end elseif c=="["then local c=self:skip_sep(a)if c>=0 then self:read_long_string(a,b,c)return"TK_STRING"elseif c==-1 then return"["else self:lexerror(a,"invalid long string delimiter","TK_STRING")end elseif c=="+"then c=self:nextc(a)if c~="="then return"+"else self:nextc(a)return"TK_ASSIGN_ADD"end elseif c=="*"then c=self:nextc(a)if c~="="then return"*"else self:nextc(a)return"TK_ASSIGN_MUL"end elseif c=="/"then c=self:nextc(a)if c~="="then return"/"else self:nextc(a)return"TK_ASSIGN_DIV"end elseif c=="%"then c=self:nextc(a)if c~="="then return"%"else self:nextc(a)return"TK_ASSIGN_MOD"end elseif c=="^"then c=self:nextc(a)if c~="="then return"^"else self:nextc(a)return"TK_ASSIGN_POW"end elseif c=="="then c=self:nextc(a)if c~="="then return"="else self:nextc(a)return"TK_EQ"end elseif c=="<"then c=self:nextc(a)if c~="="then return"<"else self:nextc(a)return"TK_LE"end elseif c==">"then c=self:nextc(a)if c~="="then return">"else self:nextc(a)return"TK_GE"end elseif c=="~"then c=self:nextc(a)if c~="="then return"~"else self:nextc(a)return"TK_NE"end elseif c=="\""or c=="'"then self:read_string(a,c,b)return"TK_STRING"elseif c=="."then c=self:save_and_next(a)if self:check_next(a,".")then if self:check_next(a,".")then return"TK_DOTS"else return"TK_CONCAT"end elseif not string.find(c,"%d")then return"."else self:read_numeral(a,b)return"TK_NUMBER"end elseif c=="EOZ"then return"TK_EOS"else if string.find(c,"%s")then self:nextc(a)elseif string.find(c,"%d")then self:read_numeral(a,b)return"TK_NUMBER"elseif string.find(c,"[_%a]")then repeat c=self:save_and_next(a)until c=="EOZ"or not string.find(c,"[_%w]")local a=a.buff;local c=self.enums[a]if c then return c end;b.seminfo=a;return"TK_NAME"else self:nextc(a)return c end end end end;local B;local C={}C.MAXSTACK=250;function C:ttisnumber(a)if a then return type(a.value)=="number"else return false end end;function C:nvalue(a)return a.value end;function C:setnilvalue(a)a.value=nil end;function C:setsvalue(a,b)a.value=b end;C.setnvalue=C.setsvalue;C.sethvalue=C.setsvalue;C.setbvalue=C.setsvalue;function C:numadd(a,b)return a+b end;function C:numsub(a,b)return a-b end;function C:nummul(a,b)return a*b end;function C:numdiv(a,b)return a/b end;function C:nummod(a,b)return a%b end;function C:numpow(a,b)return a^b end;function C:numunm(a)return-a end;function C:numisnan(a)return not a==a end;C.NO_JUMP=-1;C.BinOpr={OPR_ADD=0,OPR_SUB=1,OPR_MUL=2,OPR_DIV=3,OPR_MOD=4,OPR_POW=5,OPR_CONCAT=6,OPR_NE=7,OPR_EQ=8,OPR_LT=9,OPR_LE=10,OPR_GT=11,OPR_GE=12,OPR_AND=13,OPR_OR=14,OPR_NOBINOPR=15}C.UnOpr={OPR_MINUS=0,OPR_NOT=1,OPR_LEN=2,OPR_NOUNOPR=3}function C:getcode(a,b)return a.f.code[b.info]end;function C:codeAsBx(b,c,d,e)return self:codeABx(b,c,d,e+a.MAXARG_sBx)end;function C:setmultret(a,b)self:setreturns(a,b,B.LUA_MULTRET)end;function C:hasjumps(a)return a.t~=a.f end;function C:isnumeral(a)return a.k=="VKNUM"and a.t==self.NO_JUMP and a.f==self.NO_JUMP end;function C:_nil(b,c,d)if b.pc>b.lasttarget then if b.pc==0 then if c>=b.nactvar then return end else local b=b.f.code[b.pc-1]if a:GET_OPCODE(b)=="OP_LOADNIL"then local e=a:GETARG_A(b)local f=a:GETARG_B(b)if e<=c and c<=f+1 then if c+d-1>f then a:SETARG_B(b,c+d-1)end;return end end end end;self:codeABC(b,"OP_LOADNIL",c,c+d-1,0)end;function C:jump(a)local b=a.jpc;a.jpc=self.NO_JUMP;local c=self:codeAsBx(a,"OP_JMP",0,self.NO_JUMP)c=self:concat(a,c,b)return c end;function C:ret(a,b,c)self:codeABC(a,"OP_RETURN",b,c+1,0)end;function C:condjump(a,b,c,d,e)self:codeABC(a,b,c,d,e)return self:jump(a)end;function C:fixjump(b,c,d)local e=b.f.code[c]local c=d-(c+1)assert(d~=self.NO_JUMP)if math.abs(c)>a.MAXARG_sBx then A:syntaxerror(b.ls,"control structure too long")end;a:SETARG_sBx(e,c)end;function C:getlabel(a)a.lasttarget=a.pc;return a.pc end;function C:getjump(b,c)local a=a:GETARG_sBx(b.f.code[c])if a==self.NO_JUMP then return self.NO_JUMP else return(c+1)+a end end;function C:getjumpcontrol(b,c)local d=b.f.code[c]local b=b.f.code[c-1]if c>=1 and a:testTMode(a:GET_OPCODE(b))~=0 then return b else return d end end;function C:need_value(b,c)while c~=self.NO_JUMP do local d=self:getjumpcontrol(b,c)if a:GET_OPCODE(d)~="OP_TESTSET"then return true end;c=self:getjump(b,c)end;return false end;function C:patchtestreg(b,c,d)local b=self:getjumpcontrol(b,c)if a:GET_OPCODE(b)~="OP_TESTSET"then return false end;if d~=a.NO_REG and d~=a:GETARG_B(b)then a:SETARG_A(b,d)else a:SET_OPCODE(b,"OP_TEST")local c=a:GETARG_B(b)a:SETARG_A(b,c)a:SETARG_B(b,0)end;return true end;function C:removevalues(b,c)while c~=self.NO_JUMP do self:patchtestreg(b,c,a.NO_REG)c=self:getjump(b,c)end end;function C:patchlistaux(a,b,c,d,e)while b~=self.NO_JUMP do local f=self:getjump(a,b)if self:patchtestreg(a,b,d)then self:fixjump(a,b,c)else self:fixjump(a,b,e)end;b=f end end;function C:dischargejpc(b)self:patchlistaux(b,b.jpc,b.pc,a.NO_REG,b.pc)b.jpc=self.NO_JUMP end;function C:patchlist(b,c,d)if d==b.pc then self:patchtohere(b,c)else assert(d<b.pc)self:patchlistaux(b,c,d,a.NO_REG,d)end end;function C:patchtohere(a,b)self:getlabel(a)a.jpc=self:concat(a,a.jpc,b)end;function C:concat(a,b,c)if c==self.NO_JUMP then return b elseif b==self.NO_JUMP then return c else local b=b;local d=self:getjump(a,b)while d~=self.NO_JUMP do b=d;d=self:getjump(a,b)end;self:fixjump(a,b,c)end;return b end;function C:checkstack(a,b)local b=a.freereg+b;if b>a.f.maxstacksize then if b>=self.MAXSTACK then A:syntaxerror(a.ls,"function or expression too complex")end;a.f.maxstacksize=b end end;function C:reserveregs(a,b)self:checkstack(a,b)a.freereg=a.freereg+b end;function C:freereg(b,c)if not a:ISK(c)and c>=b.nactvar then b.freereg=b.freereg-1;assert(c==b.freereg)end end;function C:freeexp(a,b)if b.k=="VNONRELOC"then self:freereg(a,b.info)end end;function C:addk(b,c,d)local e=b.L;local f=b.h[c.value]local g=b.f;if self:ttisnumber(f)then return self:nvalue(f)else f={}self:setnvalue(f,b.nk)b.h[c.value]=f;B:growvector(e,g.k,b.nk,g.sizek,nil,a.MAXARG_Bx,"constant table overflow")g.k[b.nk]=d;local a=b.nk;b.nk=b.nk+1;return a end end;function C:stringK(a,b)local c={}self:setsvalue(c,b)return self:addk(a,c,c)end;function C:numberK(a,b)local c={}self:setnvalue(c,b)return self:addk(a,c,c)end;function C:boolK(a,b)local c={}self:setbvalue(c,b)return self:addk(a,c,c)end;function C:nilK(a)local b,c={},{}self:setnilvalue(c)self:sethvalue(b,a.h)return self:addk(a,b,c)end;function C:setreturns(b,c,d)if c.k=="VCALL"then a:SETARG_C(self:getcode(b,c),d+1)elseif c.k=="VVARARG"then a:SETARG_B(self:getcode(b,c),d+1)a:SETARG_A(self:getcode(b,c),b.freereg)C:reserveregs(b,1)end end;function C:setoneret(b,c)if c.k=="VCALL"then c.k="VNONRELOC"c.info=a:GETARG_A(self:getcode(b,c))elseif c.k=="VVARARG"then a:SETARG_B(self:getcode(b,c),2)c.k="VRELOCABLE"end end;function C:dischargevars(a,b)local c=b.k;if c=="VLOCAL"then b.k="VNONRELOC"elseif c=="VUPVAL"then b.info=self:codeABC(a,"OP_GETUPVAL",0,b.info,0)b.k="VRELOCABLE"elseif c=="VGLOBAL"then b.info=self:codeABx(a,"OP_GETGLOBAL",0,b.info)b.k="VRELOCABLE"elseif c=="VINDEXED"then self:freereg(a,b.aux)self:freereg(a,b.info)b.info=self:codeABC(a,"OP_GETTABLE",0,b.info,b.aux)b.k="VRELOCABLE"elseif c=="VVARARG"or c=="VCALL"then self:setoneret(a,b)else end end;function C:code_label(a,b,c,d)self:getlabel(a)return self:codeABC(a,"OP_LOADBOOL",b,c,d)end;function C:discharge2reg(b,c,d)self:dischargevars(b,c)local e=c.k;if e=="VNIL"then self:_nil(b,d,1)elseif e=="VFALSE"or e=="VTRUE"then self:codeABC(b,"OP_LOADBOOL",d,(c.k=="VTRUE")and 1 or 0,0)elseif e=="VK"then self:codeABx(b,"OP_LOADK",d,c.info)elseif e=="VKNUM"then self:codeABx(b,"OP_LOADK",d,self:numberK(b,c.nval))elseif e=="VRELOCABLE"then local b=self:getcode(b,c)a:SETARG_A(b,d)elseif e=="VNONRELOC"then if d~=c.info then self:codeABC(b,"OP_MOVE",d,c.info,0)end else assert(c.k=="VVOID"or c.k=="VJMP")return end;c.info=d;c.k="VNONRELOC"end;function C:discharge2anyreg(a,b)if b.k~="VNONRELOC"then self:reserveregs(a,1)self:discharge2reg(a,b,a.freereg-1)end end;function C:exp2reg(a,b,c)self:discharge2reg(a,b,c)if b.k=="VJMP"then b.t=self:concat(a,b.t,b.info)end;if self:hasjumps(b)then local d;local e=self.NO_JUMP;local f=self.NO_JUMP;if self:need_value(a,b.t)or self:need_value(a,b.f)then local b=(b.k=="VJMP")and self.NO_JUMP or self:jump(a)e=self:code_label(a,c,0,1)f=self:code_label(a,c,1,0)self:patchtohere(a,b)end;d=self:getlabel(a)self:patchlistaux(a,b.f,d,c,e)self:patchlistaux(a,b.t,d,c,f)end;b.f,b.t=self.NO_JUMP,self.NO_JUMP;b.info=c;b.k="VNONRELOC"end;function C:exp2nextreg(a,b)self:dischargevars(a,b)self:freeexp(a,b)self:reserveregs(a,1)self:exp2reg(a,b,a.freereg-1)end;function C:exp2anyreg(a,b)self:dischargevars(a,b)if b.k=="VNONRELOC"then if not self:hasjumps(b)then return b.info end;if b.info>=a.nactvar then self:exp2reg(a,b,b.info)return b.info end end;self:exp2nextreg(a,b)return b.info end;function C:exp2val(a,b)if self:hasjumps(b)then self:exp2anyreg(a,b)else self:dischargevars(a,b)end end;function C:exp2RK(b,c)self:exp2val(b,c)local d=c.k;if d=="VKNUM"or d=="VTRUE"or d=="VFALSE"or d=="VNIL"then if b.nk<=a.MAXINDEXRK then if c.k=="VNIL"then c.info=self:nilK(b)else c.info=(c.k=="VKNUM")and self:numberK(b,c.nval)or self:boolK(b,c.k=="VTRUE")end;c.k="VK"return a:RKASK(c.info)end elseif d=="VK"then if c.info<=a.MAXINDEXRK then return a:RKASK(c.info)end else end;return self:exp2anyreg(b,c)end;function C:storevar(a,b,c)local d=b.k;if d=="VLOCAL"then self:freeexp(a,c)self:exp2reg(a,c,b.info)return elseif d=="VUPVAL"then local c=self:exp2anyreg(a,c)self:codeABC(a,"OP_SETUPVAL",c,b.info,0)elseif d=="VGLOBAL"then local c=self:exp2anyreg(a,c)self:codeABx(a,"OP_SETGLOBAL",c,b.info)elseif d=="VINDEXED"then local c=self:exp2RK(a,c)self:codeABC(a,"OP_SETTABLE",b.info,b.aux,c)else assert(0)end;self:freeexp(a,c)end;function C:_self(a,b,c)self:exp2anyreg(a,b)self:freeexp(a,b)local d=a.freereg;self:reserveregs(a,2)self:codeABC(a,"OP_SELF",d,b.info,self:exp2RK(a,c))self:freeexp(a,c)b.info=d;b.k="VNONRELOC"end;function C:invertjump(b,c)local b=self:getjumpcontrol(b,c.info)assert(a:testTMode(a:GET_OPCODE(b))~=0 and a:GET_OPCODE(b)~="OP_TESTSET"and a:GET_OPCODE(b)~="OP_TEST")a:SETARG_A(b,(a:GETARG_A(b)==0)and 1 or 0)end;function C:jumponcond(b,c,d)if c.k=="VRELOCABLE"then local c=self:getcode(b,c)if a:GET_OPCODE(c)=="OP_NOT"then b.pc=b.pc-1;return self:condjump(b,"OP_TEST",a:GETARG_B(c),0,d and 0 or 1)end end;self:discharge2anyreg(b,c)self:freeexp(b,c)return self:condjump(b,"OP_TESTSET",a.NO_REG,c.info,d and 1 or 0)end;function C:goiftrue(a,b)local c;self:dischargevars(a,b)local d=b.k;if d=="VK"or d=="VKNUM"or d=="VTRUE"then c=self.NO_JUMP elseif d=="VFALSE"then c=self:jump(a)elseif d=="VJMP"then self:invertjump(a,b)c=b.info else c=self:jumponcond(a,b,false)end;b.f=self:concat(a,b.f,c)self:patchtohere(a,b.t)b.t=self.NO_JUMP end;function C:goiffalse(a,b)local c;self:dischargevars(a,b)local d=b.k;if d=="VNIL"or d=="VFALSE"then c=self.NO_JUMP elseif d=="VTRUE"then c=self:jump(a)elseif d=="VJMP"then c=b.info else c=self:jumponcond(a,b,true)end;b.t=self:concat(a,b.t,c)self:patchtohere(a,b.f)b.f=self.NO_JUMP end;function C:codenot(a,b)self:dischargevars(a,b)local c=b.k;if c=="VNIL"or c=="VFALSE"then b.k="VTRUE"elseif c=="VK"or c=="VKNUM"or c=="VTRUE"then b.k="VFALSE"elseif c=="VJMP"then self:invertjump(a,b)elseif c=="VRELOCABLE"or c=="VNONRELOC"then self:discharge2anyreg(a,b)self:freeexp(a,b)b.info=self:codeABC(a,"OP_NOT",0,b.info,0)b.k="VRELOCABLE"else assert(0)end;b.f,b.t=b.t,b.f;self:removevalues(a,b.f)self:removevalues(a,b.t)end;function C:indexed(a,b,c)b.aux=self:exp2RK(a,c)b.k="VINDEXED"end;function C:constfolding(a,b,c)local d;if not self:isnumeral(b)or not self:isnumeral(c)then return false end;local e=b.nval;local c=c.nval;if a=="OP_ADD"then d=self:numadd(e,c)elseif a=="OP_SUB"then d=self:numsub(e,c)elseif a=="OP_MUL"then d=self:nummul(e,c)elseif a=="OP_DIV"then if c==0 then return false end;d=self:numdiv(e,c)elseif a=="OP_MOD"then if c==0 then return false end;d=self:nummod(e,c)elseif a=="OP_POW"then d=self:numpow(e,c)elseif a=="OP_UNM"then d=self:numunm(e)elseif a=="OP_LEN"then return false else assert(0)d=0 end;if self:numisnan(d)then return false end;b.nval=d;return true end;function C:codearith(a,b,c,d)if self:constfolding(b,c,d)then return else local e=(b~="OP_UNM"and b~="OP_LEN")and self:exp2RK(a,d)or 0;local f=self:exp2RK(a,c)if f>e then self:freeexp(a,c)self:freeexp(a,d)else self:freeexp(a,d)self:freeexp(a,c)end;c.info=self:codeABC(a,b,0,f,e)c.k="VRELOCABLE"end end;function C:codecomp(a,b,c,d,e)local f=self:exp2RK(a,d)local g=self:exp2RK(a,e)self:freeexp(a,e)self:freeexp(a,d)if c==0 and b~="OP_EQ"then f,g=g,f;c=1 end;d.info=self:condjump(a,b,c,f,g)d.k="VJMP"end;function C:prefix(a,b,c)local d={}d.t,d.f=self.NO_JUMP,self.NO_JUMP;d.k="VKNUM"d.nval=0;if b=="OPR_MINUS"then if not self:isnumeral(c)then self:exp2anyreg(a,c)end;self:codearith(a,"OP_UNM",c,d)elseif b=="OPR_NOT"then self:codenot(a,c)elseif b=="OPR_LEN"then self:exp2anyreg(a,c)self:codearith(a,"OP_LEN",c,d)else assert(0)end end;function C:infix(a,b,c)if b=="OPR_AND"then self:goiftrue(a,c)elseif b=="OPR_OR"then self:goiffalse(a,c)elseif b=="OPR_CONCAT"then self:exp2nextreg(a,c)elseif b=="OPR_ADD"or b=="OPR_SUB"or b=="OPR_MUL"or b=="OPR_DIV"or b=="OPR_MOD"or b=="OPR_POW"then if not self:isnumeral(c)then self:exp2RK(a,c)end else self:exp2RK(a,c)end end;C.arith_op={OPR_ADD="OP_ADD",OPR_SUB="OP_SUB",OPR_MUL="OP_MUL",OPR_DIV="OP_DIV",OPR_MOD="OP_MOD",OPR_POW="OP_POW"}C.comp_op={OPR_EQ="OP_EQ",OPR_NE="OP_EQ",OPR_LT="OP_LT",OPR_LE="OP_LE",OPR_GT="OP_LT",OPR_GE="OP_LE"}C.comp_cond={OPR_EQ=1,OPR_NE=0,OPR_LT=1,OPR_LE=1,OPR_GT=0,OPR_GE=0}function C:posfix(b,c,d,e)local function f(a,b)a.k=b.k;a.info=b.info;a.aux=b.aux;a.nval=b.nval;a.t=b.t;a.f=b.f end;if c=="OPR_AND"then assert(d.t==self.NO_JUMP)self:dischargevars(b,e)e.f=self:concat(b,e.f,d.f)f(d,e)elseif c=="OPR_OR"then assert(d.f==self.NO_JUMP)self:dischargevars(b,e)e.t=self:concat(b,e.t,d.t)f(d,e)elseif c=="OPR_CONCAT"then self:exp2val(b,e)if e.k=="VRELOCABLE"and a:GET_OPCODE(self:getcode(b,e))=="OP_CONCAT"then assert(d.info==a:GETARG_B(self:getcode(b,e))-1)self:freeexp(b,d)a:SETARG_B(self:getcode(b,e),d.info)d.k="VRELOCABLE"d.info=e.info else self:exp2nextreg(b,e)self:codearith(b,"OP_CONCAT",d,e)end else local a=self.arith_op[c]if a then self:codearith(b,a,d,e)else local a=self.comp_op[c]if a then self:codecomp(b,a,self.comp_cond[c],d,e)else assert(0)end end end end;function C:fixline(a,b)a.f.lineinfo[a.pc-1]=b end;function C:code(a,b,c)local d=a.f;self:dischargejpc(a)B:growvector(a.L,d.code,a.pc,d.sizecode,nil,B.MAX_INT,"code size overflow")d.code[a.pc]=b;B:growvector(a.L,d.lineinfo,a.pc,d.sizelineinfo,nil,B.MAX_INT,"code size overflow")d.lineinfo[a.pc]=c;local b=a.pc;a.pc=a.pc+1;return b end;function C:codeABC(b,c,d,e,f)assert(a:getOpMode(c)==a.OpMode.iABC)assert(a:getBMode(c)~=a.OpArgMask.OpArgN or e==0)assert(a:getCMode(c)~=a.OpArgMask.OpArgN or f==0)return self:code(b,a:CREATE_ABC(c,d,e,f),b.ls.lastline)end;function C:codeABx(b,c,d,e)assert(a:getOpMode(c)==a.OpMode.iABx or a:getOpMode(c)==a.OpMode.iAsBx)assert(a:getCMode(c)==a.OpArgMask.OpArgN)return self:code(b,a:CREATE_ABx(c,d,e),b.ls.lastline)end;function C:setlist(b,c,d,e)local d=math.floor((d-1)/a.LFIELDS_PER_FLUSH)+1;local f=(e==B.LUA_MULTRET)and 0 or e;assert(e~=0)if d<=a.MAXARG_C then self:codeABC(b,"OP_SETLIST",c,f,d)else self:codeABC(b,"OP_SETLIST",c,f,0)self:code(b,a:CREATE_Inst(d),b.ls.lastline)end;b.freereg=c+1 end;B={}B.LUA_QS=A.LUA_QS or"'%s'"B.SHRT_MAX=32767;B.LUAI_MAXVARS=200;B.LUAI_MAXUPVALUES=60;B.MAX_INT=A.MAX_INT or 2147483645;B.LUAI_MAXCCALLS=200;B.VARARG_HASARG=1;B.HASARG_MASK=2;B.VARARG_ISVARARG=2;B.VARARG_NEEDSARG=4;B.LUA_MULTRET=-1;function B:LUA_QL(a)return"'"..a.."'"end;function B:growvector(a,a,a,b,b,b,c)if a>=b then error(c)end end;function B:newproto(a)local a={}a.k={}a.sizek=0;a.p={}a.sizep=0;a.code={}a.sizecode=0;a.sizelineinfo=0;a.sizeupvalues=0;a.nups=0;a.upvalues={}a.numparams=0;a.is_vararg=0;a.maxstacksize=0;a.lineinfo={}a.sizelocvars=0;a.locvars={}a.lineDefined=0;a.lastlinedefined=0;a.source=nil;return a end;function B:int2fb(a)local b=0;while a>=16 do a=math.floor((a+1)/2)b=b+1 end;if a<8 then return a else return((b+1)*8)+(a-8)end end;function B:hasmultret(a)return a=="VCALL"or a=="VVARARG"end;function B:getlocvar(a,b)return a.f.locvars[a.actvar[b]]end;function B:checklimit(a,b,c,d)if b>c then self:errorlimit(a,c,d)end end;function B:anchor_token(a)if a.t.token=="TK_NAME"or a.t.token=="TK_STRING"then end end;function B:error_expected(a,b)A:syntaxerror(a,string.format(self.LUA_QS.." expected",A:token2str(a,b)))end;function B:errorlimit(a,b,c)local b=(a.f.linedefined==0)and string.format("main function has more than %d %s",b,c)or string.format("function at line %d has more than %d %s",a.f.linedefined,b,c)A:lexerror(a.ls,b,0)end;function B:testnext(a,b)if a.t.token==b then A:next(a)return true else return false end end;function B:check(a,b)if a.t.token~=b then self:error_expected(a,b)end end;function B:checknext(a,b)self:check(a,b)A:next(a)end;function B:check_condition(a,b,c)if not b then A:syntaxerror(a,c)end end;function B:check_match(a,b,c,d)if not self:testnext(a,b)then if d==a.linenumber then self:error_expected(a,b)else A:syntaxerror(a,string.format(self.LUA_QS.." expected (to close "..self.LUA_QS.." at line %d)",A:token2str(a,b),A:token2str(a,c),d))end end end;function B:str_checkname(a)self:check(a,"TK_NAME")local b=a.t.seminfo;A:next(a)return b end;function B:init_exp(a,b,c)a.f,a.t=C.NO_JUMP,C.NO_JUMP;a.k=b;a.info=c end;function B:codestring(a,b,c)self:init_exp(b,"VK",C:stringK(a.fs,c))end;function B:checkname(a,b)self:codestring(a,b,self:str_checkname(a))end;function B:registerlocalvar(a,b)local c=a.fs;local d=c.f;self:growvector(a.L,d.locvars,c.nlocvars,d.sizelocvars,nil,self.SHRT_MAX,"too many local variables")d.locvars[c.nlocvars]={}d.locvars[c.nlocvars].varname=b;local a=c.nlocvars;c.nlocvars=c.nlocvars+1;return a end;function B:new_localvarliteral(a,b,c)self:new_localvar(a,b,c)end;function B:new_localvar(a,b,c)local d=a.fs;self:checklimit(d,d.nactvar+c+1,self.LUAI_MAXVARS,"local variables")d.actvar[d.nactvar+c]=self:registerlocalvar(a,b)end;function B:adjustlocalvars(a,b)local a=a.fs;a.nactvar=a.nactvar+b;for b=b,1,-1 do self:getlocvar(a,a.nactvar-b).startpc=a.pc end end;function B:removevars(a,b)local a=a.fs;while a.nactvar>b do a.nactvar=a.nactvar-1;self:getlocvar(a,a.nactvar).endpc=a.pc end end;function B:indexupvalue(a,b,c)local d=a.f;for e=0,d.nups-1 do if a.upvalues[e].k==c.k and a.upvalues[e].info==c.info then assert(d.upvalues[e]==b)return e end end;self:checklimit(a,d.nups+1,self.LUAI_MAXUPVALUES,"upvalues")self:growvector(a.L,d.upvalues,d.nups,d.sizeupvalues,nil,self.MAX_INT,"")d.upvalues[d.nups]=b;assert(c.k=="VLOCAL"or c.k=="VUPVAL")a.upvalues[d.nups]={k=c.k,info=c.info}local a=d.nups;d.nups=d.nups+1;return a end;function B:searchvar(a,b)for c=a.nactvar-1,0,-1 do if b==self:getlocvar(a,c).varname then return c end end;return-1 end;function B:markupval(a,b)local a=a.bl;while a and a.nactvar>b do a=a.previous end;if a then a.upval=true end end;function B:singlevaraux(b,c,d,e)if b==nil then self:init_exp(d,"VGLOBAL",a.NO_REG)return"VGLOBAL"else local a=self:searchvar(b,c)if a>=0 then self:init_exp(d,"VLOCAL",a)if e==0 then self:markupval(b,a)end;return"VLOCAL"else if self:singlevaraux(b.prev,c,d,0)=="VGLOBAL"then return"VGLOBAL"end;d.info=self:indexupvalue(b,c,d)d.k="VUPVAL"return"VUPVAL"end end end;function B:singlevar(a,b)local c=self:str_checkname(a)local a=a.fs;if self:singlevaraux(a,c,b,1)=="VGLOBAL"then b.info=C:stringK(a,c)end end;function B:adjust_assign(a,b,c,d)local a=a.fs;local b=b-c;if self:hasmultret(d.k)then b=b+1;if b<=0 then b=0 end;C:setreturns(a,d,b)if b>1 then C:reserveregs(a,b-1)end else if d.k~="VVOID"then C:exp2nextreg(a,d)end;if b>0 then local c=a.freereg;C:reserveregs(a,b)C:_nil(a,c,b)end end end;function B:enterlevel(a)a.L.nCcalls=a.L.nCcalls+1;if a.L.nCcalls>self.LUAI_MAXCCALLS then A:lexerror(a,"chunk has too many syntax levels",0)end end;function B:leavelevel(a)a.L.nCcalls=a.L.nCcalls-1 end;function B:enterblock(a,b,c)b.breaklist=C.NO_JUMP;b.isbreakable=c;b.nactvar=a.nactvar;b.upval=false;b.previous=a.bl;a.bl=b;assert(a.freereg==a.nactvar)end;function B:leaveblock(a)local b=a.bl;a.bl=b.previous;self:removevars(a.ls,b.nactvar)if b.upval then C:codeABC(a,"OP_CLOSE",b.nactvar,0,0)end;assert(not b.isbreakable or not b.upval)assert(b.nactvar==a.nactvar)a.freereg=a.nactvar;C:patchtohere(a,b.breaklist)end;function B:pushclosure(b,c,d)local e=b.fs;local f=e.f;self:growvector(b.L,f.p,e.np,f.sizep,nil,a.MAXARG_Bx,"constant table overflow")f.p[e.np]=c.f;e.np=e.np+1;self:init_exp(d,"VRELOCABLE",C:codeABx(e,"OP_CLOSURE",0,e.np-1))for a=0,c.f.nups-1 do local b=(c.upvalues[a].k=="VLOCAL")and"OP_MOVE"or"OP_GETUPVAL"C:codeABC(e,b,0,c.upvalues[a].info,0)end end;function B:open_func(a,b)local c=a.L;local d=self:newproto(a.L)b.f=d;b.prev=a.fs;b.ls=a;b.L=c;a.fs=b;b.pc=0;b.lasttarget=-1;b.jpc=C.NO_JUMP;b.freereg=0;b.nk=0;b.np=0;b.nlocvars=0;b.nactvar=0;b.bl=nil;d.source=a.source;d.maxstacksize=2;b.h={}end;function B:close_func(a)local b=a.L;local b=a.fs;local c=b.f;self:removevars(a,0)C:ret(b,0,0)c.sizecode=b.pc;c.sizelineinfo=b.pc;c.sizek=b.nk;c.sizep=b.np;c.sizelocvars=b.nlocvars;c.sizeupvalues=c.nups;assert(b.bl==nil)a.fs=b.prev;if b then self:anchor_token(a)end end;function B:parser(a,b,c,d)local e={}e.t={}e.lookahead={}local f={}f.upvalues={}f.actvar={}a.nCcalls=0;e.buff=c;A:setinput(a,e,b,d)self:open_func(e,f)f.f.is_vararg=self.VARARG_ISVARARG;A:next(e)self:chunk(e)self:check(e,"TK_EOS")self:close_func(e)assert(f.prev==nil)assert(f.f.nups==0)assert(e.fs==nil)return f.f end;function B:field(a,b)local c=a.fs;local d={}C:exp2anyreg(c,b)A:next(a)self:checkname(a,d)C:indexed(c,b,d)end;function B:yindex(a,b)A:next(a)self:expr(a,b)C:exp2val(a.fs,b)self:checknext(a,"]")end;function B:recfield(a,b)local c=a.fs;local d=a.fs.freereg;local e,f={},{}if a.t.token=="TK_NAME"then self:checklimit(c,b.nh,self.MAX_INT,"items in a constructor")self:checkname(a,e)else self:yindex(a,e)end;b.nh=b.nh+1;self:checknext(a,"=")local e=C:exp2RK(c,e)self:expr(a,f)C:codeABC(c,"OP_SETTABLE",b.t.info,e,C:exp2RK(c,f))c.freereg=d end;function B:closelistfield(b,c)if c.v.k=="VVOID"then return end;C:exp2nextreg(b,c.v)c.v.k="VVOID"if c.tostore==a.LFIELDS_PER_FLUSH then C:setlist(b,c.t.info,c.na,c.tostore)c.tostore=0 end end;function B:lastlistfield(a,b)if b.tostore==0 then return end;if self:hasmultret(b.v.k)then C:setmultret(a,b.v)C:setlist(a,b.t.info,b.na,self.LUA_MULTRET)b.na=b.na-1 else if b.v.k~="VVOID"then C:exp2nextreg(a,b.v)end;C:setlist(a,b.t.info,b.na,b.tostore)end end;function B:listfield(a,b)self:expr(a,b.v)self:checklimit(a.fs,b.na,self.MAX_INT,"items in a constructor")b.na=b.na+1;b.tostore=b.tostore+1 end;function B:constructor(b,c)local d=b.fs;local e=b.linenumber;local f=C:codeABC(d,"OP_NEWTABLE",0,0,0)local g={}g.v={}g.na,g.nh,g.tostore=0,0,0;g.t=c;self:init_exp(c,"VRELOCABLE",f)self:init_exp(g.v,"VVOID",0)C:exp2nextreg(b.fs,c)self:checknext(b,"{")repeat assert(g.v.k=="VVOID"or g.tostore>0)if b.t.token=="}"then break end;self:closelistfield(d,g)local a=b.t.token;if a=="TK_NAME"then A:lookahead(b)if b.lookahead.token~="="then self:listfield(b,g)else self:recfield(b,g)end elseif a=="["then self:recfield(b,g)else self:listfield(b,g)end until not self:testnext(b,",")and not self:testnext(b,";")self:check_match(b,"}","{",e)self:lastlistfield(d,g)a:SETARG_B(d.f.code[f],self:int2fb(g.na))a:SETARG_C(d.f.code[f],self:int2fb(g.nh))end;function B:parlist(a)local b=a.fs;local c=b.f;local d=0;c.is_vararg=0;if a.t.token~=")"then repeat local b=a.t.token;if b=="TK_NAME"then self:new_localvar(a,self:str_checkname(a),d)d=d+1 elseif b=="TK_DOTS"then A:next(a)self:new_localvarliteral(a,"arg",d)d=d+1;c.is_vararg=self.VARARG_HASARG+self.VARARG_NEEDSARG;c.is_vararg=c.is_vararg+self.VARARG_ISVARARG else A:syntaxerror(a,"<name> or "..self:LUA_QL("...").." expected")end until c.is_vararg~=0 or not self:testnext(a,",")end;self:adjustlocalvars(a,d)c.numparams=b.nactvar-(c.is_vararg%self.HASARG_MASK)C:reserveregs(b,b.nactvar)end;function B:body(a,b,c,d)local e={}e.upvalues={}e.actvar={}self:open_func(a,e)e.f.lineDefined=d;self:checknext(a,"(")if c then self:new_localvarliteral(a,"self",0)self:adjustlocalvars(a,1)end;self:parlist(a)self:checknext(a,")")self:chunk(a)e.f.lastlinedefined=a.linenumber;self:check_match(a,"TK_END","TK_FUNCTION",d)self:close_func(a)self:pushclosure(a,e,b)end;function B:explist1(a,b)local c=1;self:expr(a,b)while self:testnext(a,",")do C:exp2nextreg(a.fs,b)self:expr(a,b)c=c+1 end;return c end;function B:funcargs(a,b)local c=a.fs;local d={}local e;local f=a.linenumber;local g=a.t.token;if g=="("then if f~=a.lastline then A:syntaxerror(a,"ambiguous syntax (function call x new statement)")end;A:next(a)if a.t.token==")"then d.k="VVOID"else self:explist1(a,d)C:setmultret(c,d)end;self:check_match(a,")","(",f)elseif g=="{"then self:constructor(a,d)elseif g=="TK_STRING"then self:codestring(a,d,a.t.seminfo)A:next(a)else A:syntaxerror(a,"function arguments expected")return end;assert(b.k=="VNONRELOC")local a=b.info;if self:hasmultret(d.k)then e=self.LUA_MULTRET else if d.k~="VVOID"then C:exp2nextreg(c,d)end;e=c.freereg-(a+1)end;self:init_exp(b,"VCALL",C:codeABC(c,"OP_CALL",a,e+1,2))C:fixline(c,f)c.freereg=a+1 end;function B:prefixexp(a,b)local c=a.t.token;if c=="("then local c=a.linenumber;A:next(a)self:expr(a,b)self:check_match(a,")","(",c)C:dischargevars(a.fs,b)elseif c=="TK_NAME"then self:singlevar(a,b)else A:syntaxerror(a,"unexpected symbol")end;return end;function B:primaryexp(a,b)local c=a.fs;self:prefixexp(a,b)while true do local d=a.t.token;if d=="."then self:field(a,b)elseif d=="["then local d={}C:exp2anyreg(c,b)self:yindex(a,d)C:indexed(c,b,d)elseif d==":"then local d={}A:next(a)self:checkname(a,d)C:_self(c,b,d)self:funcargs(a,b)elseif d=="("or d=="TK_STRING"or d=="{"then C:exp2nextreg(c,b)self:funcargs(a,b)else return end end end;function B:simpleexp(a,b)local c=a.t.token;if c=="TK_NUMBER"then self:init_exp(b,"VKNUM",0)b.nval=a.t.seminfo elseif c=="TK_STRING"then self:codestring(a,b,a.t.seminfo)elseif c=="TK_NIL"then self:init_exp(b,"VNIL",0)elseif c=="TK_TRUE"then self:init_exp(b,"VTRUE",0)elseif c=="TK_FALSE"then self:init_exp(b,"VFALSE",0)elseif c=="TK_DOTS"then local c=a.fs;self:check_condition(a,c.f.is_vararg~=0,"cannot use "..self:LUA_QL("...").." outside a vararg function")local a=c.f.is_vararg;if a>=self.VARARG_NEEDSARG then c.f.is_vararg=a-self.VARARG_NEEDSARG end;self:init_exp(b,"VVARARG",C:codeABC(c,"OP_VARARG",0,1,0))elseif c=="{"then self:constructor(a,b)return elseif c=="TK_FUNCTION"then A:next(a)self:body(a,b,false,a.linenumber)return else self:primaryexp(a,b)return end;A:next(a)end;function B:getunopr(a)if a=="TK_NOT"then return"OPR_NOT"elseif a=="-"then return"OPR_MINUS"elseif a=="#"then return"OPR_LEN"else return"OPR_NOUNOPR"end end;B.getbinopr_table={["+"]="OPR_ADD",["-"]="OPR_SUB",["*"]="OPR_MUL",["/"]="OPR_DIV",["%"]="OPR_MOD",["^"]="OPR_POW",["TK_CONCAT"]="OPR_CONCAT",["TK_NE"]="OPR_NE",["TK_EQ"]="OPR_EQ",["<"]="OPR_LT",["TK_LE"]="OPR_LE",[">"]="OPR_GT",["TK_GE"]="OPR_GE",["TK_AND"]="OPR_AND",["TK_OR"]="OPR_OR"}function B:getbinopr(a)local a=self.getbinopr_table[a]if a then return a else return"OPR_NOBINOPR"end end;B.COMPOUND_OP_TRANSLATE={TK_ASSIGN_ADD="OP_ADD",TK_ASSIGN_SUB="OP_SUB",TK_ASSIGN_MUL="OP_MUL",TK_ASSIGN_DIV="OP_DIV",TK_ASSIGN_MOD="OP_MOD",TK_ASSIGN_POW="OP_POW"}function B:getcompopr(a)local a=self.COMPOUND_OP_TRANSLATE[a]if a then return a else return"OP_NOCOMOPR"end end;B.priority={{6,6},{6,6},{7,7},{7,7},{7,7},{10,9},{5,4},{3,3},{3,3},{3,3},{3,3},{3,3},{3,3},{2,2},{1,1}}B.UNARY_PRIORITY=8;function B:subexpr(a,b,c)self:enterlevel(a)local d=self:getunopr(a.t.token)if d~="OPR_NOUNOPR"then A:next(a)self:subexpr(a,b,self.UNARY_PRIORITY)C:prefix(a.fs,d,b)else self:simpleexp(a,b)end;local d=self:getbinopr(a.t.token)while d~="OPR_NOBINOPR"and self.priority[C.BinOpr[d]+1][1]>c do local c={}A:next(a)C:infix(a.fs,d,b)local e=self:subexpr(a,c,self.priority[C.BinOpr[d]+1][2])C:posfix(a.fs,d,b,c)d=e end;self:leavelevel(a)return d end;function B:expr(a,b)self:subexpr(a,b,0)end;function B:block_follow(a)if a=="TK_ELSE"or a=="TK_ELSEIF"or a=="TK_END"or a=="TK_UNTIL"or a=="TK_EOS"then return true else return false end end;function B:block(a)local b=a.fs;local c={}self:enterblock(b,c,false)self:chunk(a)assert(c.breaklist==C.NO_JUMP)self:leaveblock(b)end;function B:check_conflict(a,b,c)local a=a.fs;local d=a.freereg;local e=false;while b do if b.v.k=="VINDEXED"then if b.v.info==c.info then e=true;b.v.info=d end;if b.v.aux==c.info then e=true;b.v.aux=d end end;b=b.prev end;if e then C:codeABC(a,"OP_MOVE",a.freereg,c.info,0)C:reserveregs(a,1)end end;function B:assignment(a,b,c)local d={}local e=b.v.k;self:check_condition(a,e=="VLOCAL"or e=="VUPVAL"or e=="VGLOBAL"or e=="VINDEXED","syntax error")if self:testnext(a,",")then local d={}d.v={}d.prev=b;self:primaryexp(a,d.v)if d.v.k=="VLOCAL"then self:check_conflict(a,b,d.v)end;self:checklimit(a.fs,c,self.LUAI_MAXCCALLS-a.L.nCcalls,"variables in assignment")self:assignment(a,d,c+1)else local e=self:getcompopr(a.t.token)if e~="OP_NOCOMOPR"then A:next(a)else self:checknext(a,"=")end;local f=self:explist1(a,d)if f~=c then self:adjust_assign(a,c,f,d)if f>c then a.fs.freereg=a.fs.freereg-(f-c)end else C:setoneret(a.fs,d)if e~="OP_NOCOMOPR"then C:exp2val(a.fs,b.v)C:exp2val(a.fs,d)C:codearith(a.fs,e,b.v,d)end;C:storevar(a.fs,b.v,d)return end end;self:init_exp(d,"VNONRELOC",a.fs.freereg-1)C:storevar(a.fs,b.v,d)end;function B:cond(a)local b={}self:expr(a,b)if b.k=="VNIL"then b.k="VFALSE"end;C:goiftrue(a.fs,b)return b.f end;function B:breakstat(a)local b=a.fs;local c=b.bl;local d=false;while c and not c.isbreakable do if c.upval then d=true end;c=c.previous end;if not c then A:syntaxerror(a,"no loop to break")end;if d then C:codeABC(b,"OP_CLOSE",c.nactvar,0,0)end;c.breaklist=C:concat(b,c.breaklist,C:jump(b))end;function B:continuestat(a)local b=a.fs;local c=b.bl;local d=false;while c and not c.isbreakable do if c.upval then d=true end;c=c.previous end;if not c then A:syntaxerror(a,"no loop to continue")end;if d then C:codeABC(b,"OP_CLOSE",c.nactvar,0,0)end;C:codeAsBx(b,"OP_JMP",0,c.breaklist.previous)end;function B:whilestat(a,b)local c=a.fs;local d={}A:next(a)local e=C:getlabel(c)local f=self:cond(a)self:enterblock(c,d,true)self:checknext(a,"TK_DO")self:block(a)C:patchlist(c,C:jump(c),e)self:check_match(a,"TK_END","TK_WHILE",b)self:leaveblock(c)C:patchtohere(c,f)end;function B:repeatstat(a,b)local c=a.fs;local d=C:getlabel(c)local e,f={},{}self:enterblock(c,e,true)self:enterblock(c,f,false)A:next(a)self:chunk(a)self:check_match(a,"TK_UNTIL","TK_REPEAT",b)local b=self:cond(a)if not f.upval then self:leaveblock(c)C:patchlist(a.fs,b,d)else self:breakstat(a)C:patchtohere(a.fs,b)self:leaveblock(c)C:patchlist(a.fs,C:jump(c),d)end;self:leaveblock(c)end;function B:exp1(a)local b={}self:expr(a,b)local c=b.k;C:exp2nextreg(a.fs,b)return c end;function B:forbody(a,b,c,d,e)local f={}local g=a.fs;self:adjustlocalvars(a,3)self:checknext(a,"TK_DO")local h=e and C:codeAsBx(g,"OP_FORPREP",b,C.NO_JUMP)or C:jump(g)self:enterblock(g,f,false)self:adjustlocalvars(a,d)C:reserveregs(g,d)self:block(a)self:leaveblock(g)C:patchtohere(g,h)local a=e and C:codeAsBx(g,"OP_FORLOOP",b,C.NO_JUMP)or C:codeABC(g,"OP_TFORLOOP",b,0,d)C:fixline(g,c)C:patchlist(g,e and a or C:jump(g),h+1)end;function B:fornum(a,b,c)local d=a.fs;local e=d.freereg;self:new_localvarliteral(a,"(for index)",0)self:new_localvarliteral(a,"(for limit)",1)self:new_localvarliteral(a,"(for step)",2)self:new_localvar(a,b,3)self:checknext(a,'=')self:exp1(a)self:checknext(a,",")self:exp1(a)if self:testnext(a,",")then self:exp1(a)else C:codeABx(d,"OP_LOADK",d.freereg,C:numberK(d,1))C:reserveregs(d,1)end;self:forbody(a,e,c,1,true)end;function B:forlist(a,b)local c=a.fs;local d={}local e=0;local f=c.freereg;self:new_localvarliteral(a,"(for generator)",e)e=e+1;self:new_localvarliteral(a,"(for state)",e)e=e+1;self:new_localvarliteral(a,"(for control)",e)e=e+1;self:new_localvar(a,b,e)e=e+1;while self:testnext(a,",")do self:new_localvar(a,self:str_checkname(a),e)e=e+1 end;self:checknext(a,"TK_IN")local b=a.linenumber;self:adjust_assign(a,3,self:explist1(a,d),d)C:checkstack(c,3)self:forbody(a,f,b,e-3,false)end;function B:forstat(a,b)local c=a.fs;local d={}self:enterblock(c,d,true)A:next(a)local d=self:str_checkname(a)local e=a.t.token;if e=="="then self:fornum(a,d,b)elseif e==","or e=="TK_IN"then self:forlist(a,d)else A:syntaxerror(a,self:LUA_QL("=").." or "..self:LUA_QL("in").." expected")end;self:check_match(a,"TK_END","TK_FOR",b)self:leaveblock(c)end;function B:test_then_block(a)A:next(a)local b=self:cond(a)self:checknext(a,"TK_THEN")self:block(a)return b end;function B:ifstat(a,b)local c=a.fs;local d=C.NO_JUMP;local e=self:test_then_block(a)while a.t.token=="TK_ELSEIF"do d=C:concat(c,d,C:jump(c))C:patchtohere(c,e)e=self:test_then_block(a)end;if a.t.token=="TK_ELSE"then d=C:concat(c,d,C:jump(c))C:patchtohere(c,e)A:next(a)self:block(a)else d=C:concat(c,d,e)end;C:patchtohere(c,d)self:check_match(a,"TK_END","TK_IF",b)end;function B:localfunc(a)local b,c={},{}local d=a.fs;self:new_localvar(a,self:str_checkname(a),0)self:init_exp(b,"VLOCAL",d.freereg)C:reserveregs(d,1)self:adjustlocalvars(a,1)self:body(a,c,false,a.linenumber)C:storevar(d,b,c)self:getlocvar(d,d.nactvar-1).startpc=d.pc end;function B:localstat(a)local b=0;local c;local d={}repeat self:new_localvar(a,self:str_checkname(a),b)b=b+1 until not self:testnext(a,",")if self:testnext(a,"=")then c=self:explist1(a,d)else d.k="VVOID"c=0 end;self:adjust_assign(a,b,c,d)self:adjustlocalvars(a,b)end;function B:funcname(a,b)local c=false;self:singlevar(a,b)while a.t.token=="."do self:field(a,b)end;if a.t.token==":"then c=true;self:field(a,b)end;return c end;function B:funcstat(a,b)local c,d={},{}A:next(a)local e=self:funcname(a,c)self:body(a,d,e,b)C:storevar(a.fs,c,d)C:fixline(a.fs,b)end;function B:exprstat(b)local c=b.fs;local d={}d.v={}self:primaryexp(b,d.v)if d.v.k=="VCALL"then a:SETARG_C(C:getcode(c,d.v),1)else d.prev=nil;self:assignment(b,d,1)end end;function B:retstat(b)local c=b.fs;local d={}local e,f;A:next(b)if self:block_follow(b.t.token)or b.t.token==";"then e,f=0,0 else f=self:explist1(b,d)if self:hasmultret(d.k)then C:setmultret(c,d)if d.k=="VCALL"and f==1 then a:SET_OPCODE(C:getcode(c,d),"OP_TAILCALL")assert(a:GETARG_A(C:getcode(c,d))==c.nactvar)end;e=c.nactvar;f=self.LUA_MULTRET else if f==1 then e=C:exp2anyreg(c,d)else C:exp2nextreg(c,d)e=c.nactvar;assert(f==c.freereg-e)end end end;C:ret(c,e,f)end;function B:statement(a)local b=a.linenumber;local c=a.t.token;if c=="TK_IF"then self:ifstat(a,b)return false elseif c=="TK_WHILE"then self:whilestat(a,b)return false elseif c=="TK_DO"then A:next(a)self:block(a)self:check_match(a,"TK_END","TK_DO",b)return false elseif c=="TK_FOR"then self:forstat(a,b)return false elseif c=="TK_REPEAT"then self:repeatstat(a,b)return false elseif c=="TK_FUNCTION"then self:funcstat(a,b)return false elseif c=="TK_LOCAL"then A:next(a)if self:testnext(a,"TK_FUNCTION")then self:localfunc(a)else self:localstat(a)end;return false elseif c=="TK_RETURN"then self:retstat(a)return true elseif c=="TK_BREAK"then A:next(a)self:breakstat(a)return true elseif c=="TK_CONTINUE"then A:next(a)self:continuestat(a)return true else self:exprstat(a)return false end end;function B:chunk(a)local b=false;self:enterlevel(a)while not b and not self:block_follow(a.t.token)do b=self:statement(a)self:testnext(a,";")assert(a.fs.f.maxstacksize>=a.fs.freereg and a.fs.freereg>=a.fs.nactvar)a.fs.freereg=a.fs.nactvar end;self:leavelevel(a)end;local a=bit32;local C=table.unpack or unpack;local D;local E;local F;local G=50;local H={[22]=18,[31]=8,[33]=28,[0]=3,[1]=13,[2]=23,[26]=33,[12]=1,[13]=6,[14]=10,[15]=16,[16]=20,[17]=26,[18]=30,[19]=36,[3]=0,[4]=2,[5]=4,[6]=7,[7]=9,[8]=12,[9]=14,[10]=17,[20]=19,[21]=22,[23]=24,[24]=27,[25]=29,[27]=32,[32]=34,[34]=37,[11]=5,[28]=11,[29]=15,[30]=21,[35]=25,[36]=31,[37]=35}local I={[0]='ABC','ABx','ABC','ABC','ABC','ABx','ABC','ABx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','AsBx','ABC','ABC','ABC','ABx','ABC'}local J={[0]={b='OpArgR',c='OpArgN'},{b='OpArgK',c='OpArgN'},{b='OpArgU',c='OpArgU'},{b='OpArgR',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgK',c='OpArgN'},{b='OpArgR',c='OpArgK'},{b='OpArgK',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgK',c='OpArgK'},{b='OpArgU',c='OpArgU'},{b='OpArgR',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgR'},{b='OpArgR',c='OpArgN'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgR',c='OpArgU'},{b='OpArgR',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgU',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgN',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgN',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgU',c='OpArgN'}}local function K(a,b,c,d)local e=0;for c=b,c,d do e=e+string.byte(a,c,c)*256^(c-b)end;return e end;local function L(b,c,d,e)local f=(-1)^a.rshift(e,7)local e=a.rshift(d,7)+a.lshift(a.band(e,127),1)local a=b+a.lshift(c,8)+a.lshift(a.band(d,127),16)local b=1;if e==0 then if a==0 then return f*0 else b=0;e=1 end elseif e==127 then if a==0 then return f*(1/0)else return f*(0/0)end end;return f*2^(e-127)*(1+b/2^23)end;local function M(b,c,d,e,f,g,h,i)local j=(-1)^a.rshift(i,7)local i=a.lshift(a.band(i,127),4)+a.rshift(h,4)local a=a.band(h,15)*2^48;local h=1;a=a+(g*2^40)+(f*2^32)+(e*2^24)+(d*2^16)+(c*2^8)+b;if i==0 then if a==0 then return j*0 else h=0;i=1 end elseif i==2047 then if a==0 then return j*(1/0)else return j*(0/0)end end;return j*2^(i-1023)*(h+a/2^52)end;local function N(a,b,c)return K(a,b,c-1,1)end;local function O(a,b,c)return K(a,c-1,b,-1)end;local function K(a,b)return L(string.byte(a,b,b+3))end;local function P(a,b)local a,b,c,d=string.byte(a,b,b+3)return L(d,c,b,a)end;local function L(a,b)return M(string.byte(a,b,b+7))end;local function Q(a,b)local a,b,c,d,e,f,g,h=string.byte(a,b,b+7)return M(h,g,f,e,d,c,b,a)end;local K={[4]={little=K,big=P},[8]={little=L,big=Q}}local function L(a)local b=a.index;local c=string.byte(a.source,b,b)a.index=b+1;return c end;local function M(a,b)local b=a.index+b;local c=string.sub(a.source,a.index,b-1)a.index=b;return c end;local function P(a)local b=a:s_szt()local c;if b~=0 then c=string.sub(M(a,b),1,-2)end;return c end;local function Q(a,b)return function(c)local a=c.index+a;local b=b(c.source,c.index,a)c.index=a;return b end end;local function R(a,b)return function(c)local b=b(c.source,c.index)c.index=c.index+a;return b end end;local function S(b)local c=b:s_int()local d={}for c=1,c do local b=b:s_ins()local e=a.band(b,63)local f=I[e]local g=J[e]local e={value=b,op=H[e],A=a.band(a.rshift(b,6),255)}if f=='ABC'then e.B=a.band(a.rshift(b,23),511)e.C=a.band(a.rshift(b,14),511)e.is_KB=g.b=='OpArgK'and e.B>255;e.is_KC=g.c=='OpArgK'and e.C>255 elseif f=='ABx'then e.Bx=a.band(a.rshift(b,14),262143)e.is_K=g.b=='OpArgK'elseif f=='AsBx'then e.sBx=a.band(a.rshift(b,14),262143)-131071 end;d[c]=e end;return d end;local function a(a)local b=a:s_int()local c={}for b=1,b do local d=L(a)local e;if d==1 then e=L(a)~=0 elseif d==3 then e=a:s_num()elseif d==4 then e=P(a)end;c[b]=e end;return c end;local function I(a,b)local c=a:s_int()local d={}for c=1,c do d[c]=F(a,b)end;return d end;local function J(a)local b=a:s_int()local c={}for b=1,b do c[b]=a:s_int()end;return c end;local function T(a)local b=a:s_int()local c={}for b=1,b do c[b]={varname=P(a),startpc=a:s_int(),endpc=a:s_int()}end;return c end;local function U(a)local b=a:s_int()local c={}for b=1,b do c[b]=P(a)end;return c end;function F(b,c)local d={}local c=P(b)or c;d.source=c;b:s_int()b:s_int()d.numupvals=L(b)d.numparams=L(b)L(b)L(b)d.code=S(b)d.const=a(b)d.subs=I(b,c)d.lines=J(b)T(b)U(b)for a,a in ipairs(d.code)do if a.is_K then a.const=d.const[a.Bx+1]else if a.is_KB then a.const_B=d.const[a.B-255]end;if a.is_KC then a.const_C=d.const[a.C-255]end end end;return d end;function D(a)local b;local c;local d;local e;local f;local g;local h;local a={index=1,source=a}assert(M(a,4)=='\27Lua','invalid Lua signature')assert(L(a)==81,'invalid Lua version')assert(L(a)==0,'invalid Lua format')c=L(a)~=0;d=L(a)e=L(a)f=L(a)g=L(a)h=L(a)~=0;b=c and N or O;a.s_int=Q(d,b)a.s_szt=Q(e,b)a.s_ins=Q(f,b)if h then a.s_num=Q(g,b)elseif K[g]then a.s_num=R(g,K[g][c and'little'or'big'])else error('unsupported float size')end;return F(a,'@virtual')end;local function a(a,b)for c,d in pairs(a)do if d.index>=b then d.value=d.store[d.index]d.store=d;d.index='value'a[c]=nil end end end;local function F(a,b,c)local d=a[b]if not d then d={index=b,store=c}a[b]=d end;return d end;local function I(...)return select('#',...),{...}end;local function J(a,b)local c=a.source;local a=a.lines[a.pc-1]local d,e,f=string.match(b or'','^(.-):(%d+):%s+(.+)')local g='%s:%i: [%s:%i] %s'a=a or'0'd=d or'?'e=e or'0'f=f or b or''error(string.format(g,c,a,d,e,f),0)end;local function K(b)local c=b.code;local d=b.subs;local e=b.env;local f=b.upvals;local g=b.varargs;local h=-1;local i={}local j=b.stack;local k=b.pc;while true do local l=c[k]local m=l.op;k=k+1;if m<18 then if m<8 then if m<3 then if m<1 then for a=l.A,l.B do j[a]=nil end elseif m>1 then local a=f[l.B]j[l.A]=a.store[a.index]else local a,b;if l.is_KB then a=l.const_B else a=j[l.B]end;if l.is_KC then b=l.const_C else b=j[l.C]end;j[l.A]=a+b end elseif m>3 then if m<6 then if m>4 then local a=l.A;local b=l.B;local c;if l.is_KC then c=l.const_C else c=j[l.C]end;j[a+1]=j[b]j[a]=j[b][c]else j[l.A]=e[l.const]end elseif m>6 then local a;if l.is_KC then a=l.const_C else a=j[l.C]end;j[l.A]=j[l.B][a]else local a,b;if l.is_KB then a=l.const_B else a=j[l.B]end;if l.is_KC then b=l.const_C else b=j[l.C]end;j[l.A]=a-b end else j[l.A]=j[l.B]end elseif m>8 then if m<13 then if m<10 then e[l.const]=j[l.A]elseif m>10 then if m<12 then local a=l.A;local b=l.B;local c=l.C;local d;local e,f;if b==0 then d=h-a else d=b-1 end;e,f=I(j[a](C(j,a+1,a+d)))if c==0 then h=a+e-1 else e=c-1 end;for b=1,e do j[a+b-1]=f[b]end else local a=f[l.B]a.store[a.index]=j[l.A]end else local a,b;if l.is_KB then a=l.const_B else a=j[l.B]end;if l.is_KC then b=l.const_C else b=j[l.C]end;j[l.A]=a*b end elseif m>13 then if m<16 then if m>14 then local b=l.A;local c=l.B;local d;if c==0 then d=h-b else d=c-1 end;a(i,0)return I(j[b](C(j,b+1,b+d)))else local a,b;if l.is_KB then a=l.const_B else a=j[l.B]end;if l.is_KC then b=l.const_C else b=j[l.C]end;j[l.A][a]=b end elseif m>16 then j[l.A]={}else local a,b;if l.is_KB then a=l.const_B else a=j[l.B]end;if l.is_KC then b=l.const_C else b=j[l.C]end;j[l.A]=a/b end else j[l.A]=l.const end else local a=l.A;local b=j[a+2]local c=j[a]+b;local a=j[a+1]local d;if b==math.abs(b)then d=c<=a else d=c>=a end;if d then j[l.A]=c;j[l.A+3]=c;k=k+l.sBx end end elseif m>18 then if m<28 then if m<23 then if m<20 then j[l.A]=#j[l.B]elseif m>20 then if m<22 then local b=l.A;local c=l.B;local d={}local e;if c==0 then e=h-b+1 else e=c-1 end;for a=1,e do d[a]=j[b+a-1]end;a(i,0)return e,d else local a=j[l.B]for b=l.B+1,l.C do a=a..j[b]end;j[l.A]=a end else local a,b;if l.is_KB then a=l.const_B else a=j[l.B]end;if l.is_KC then b=l.const_C else b=j[l.C]end;j[l.A]=a%b end elseif m>23 then if m<26 then if m>24 then a(i,l.A)else local a,b;if l.is_KB then a=l.const_B else a=j[l.B]end;if l.is_KC then b=l.const_C else b=j[l.C]end;if(a==b)==(l.A~=0)then k=k+c[k].sBx end;k=k+1 end elseif m>26 then local a,b;if l.is_KB then a=l.const_B else a=j[l.B]end;if l.is_KC then b=l.const_C else b=j[l.C]end;if(a<b)==(l.A~=0)then k=k+c[k].sBx end;k=k+1 else local a,b;if l.is_KB then a=l.const_B else a=j[l.B]end;if l.is_KC then b=l.const_C else b=j[l.C]end;j[l.A]=a^b end else j[l.A]=l.B~=0;if l.C~=0 then k=k+1 end end elseif m>28 then if m<33 then if m<30 then local a,b;if l.is_KB then a=l.const_B else a=j[l.B]end;if l.is_KC then b=l.const_C else b=j[l.C]end;if(a<=b)==(l.A~=0)then k=k+c[k].sBx end;k=k+1 elseif m>30 then if m<32 then local a=d[l.Bx+1]local b=a.numupvals;local d;if b~=0 then d={}for a=1,b do local b=c[k+a-1]if b.op==H[0]then d[a-1]=F(i,b.B,j)elseif b.op==H[4]then d[a-1]=f[b.B]end end;k=k+b end;j[l.A]=E(a,e,d)else local a=l.A;local b=l.B;if(not j[b])==(l.C~=0)then k=k+1 else j[a]=j[b]end end else j[l.A]=-j[l.B]end elseif m>33 then if m<36 then if m>34 then local a=l.A;local b=l.B;if b==0 then b=g.size;h=a+b-1 end;for b=1,b do j[a+b-1]=g.list[b]end else local a=l.A;local b,c,d;b=assert(tonumber(j[a]),'`for` initial value must be a number')c=assert(tonumber(j[a+1]),'`for` limit must be a number')d=assert(tonumber(j[a+2]),'`for` step must be a number')j[a]=b-d;j[a+1]=c;j[a+2]=d;k=k+l.sBx end elseif m>36 then local a=l.A;local b=l.C;local c=l.B;local d=j[a]local e;if c==0 then c=h-a end;if b==0 then b=l[k].value;k=k+1 end;e=(b-1)*G;for b=1,c do d[b+e]=j[a+b]end else j[l.A]=not j[l.B]end else if(not j[l.A])==(l.C~=0)then k=k+1 end end else local a=l.A;local b=j[a]local c=j[a+1]local d=j[a+2]local e=a+3;local f;if not d and not c and type(b)=="table"then local e=pcall(getmetatable,b)local f=e and not pcall(setmetatable,b,getmetatable(b))or not e;local e=e and getmetatable(b)if not(table.isfrozen and table.isfrozen(b))and f and not e then warn("The table has a metatable buts it's hidden, __iter and __call won't work in forloop.")end;if not(type(e)=="table"and rawget(e,"__call"))then b,c,d=(type(e)=="table"and rawget(e,"__iter")or next),b,nil;j[a],j[a+1],j[a+2]=b,c,d end end;j[e+2]=d;j[e+1]=c;j[e]=b;f={b(c,d)}for a=1,l.C do j[e+a-1]=f[a]end;if j[e]~=nil then j[a+2]=j[e]else k=k+1 end end else k=k+l.sBx end;b.pc=k end end;function E(a,b,c)local d=a.code;local e=a.subs;local f=a.lines;local g=a.source;local a=a.numparams;local function h(...)local h={}local i={}local j=0;local k,l=I(...)local m;local n,o,p;for a=1,a do h[a-1]=l[a]end;if a<k then j=k-a;for b=1,j do i[b]=l[a+b]end end;m={varargs={list=i,size=j},code=d,subs=e,lines=f,source=g,env=b,upvals=c,stack=h,pc=1}n,o,p=pcall(K,m,...)if n then return C(p,1,o)else J(m,o)end;return end;return h end;local function a(a,b)return E(D(a),b or{})end;A:init()local A={}local function C(b,c)local d,e,f=nil,nil,nil;c=c or getfenv(2)local a,b=xpcall(function()local b=y:init(y:make_getS(b),nil)if not b then return nil,error end;local b=B:parser(A,b,nil,"NanocoreVM")e,f=z:make_setS()z:dump(A,b,e,f)d=a(f.data,c)end,function(a)return string.format("%s\n\n--- Loadstring Stacktrace Begin --- \n%s\n--- Loadstring Stacktrace End --- \n",a,debug.traceback("",2))end)if a then return d,f.data else return nil,b end end;task.spawn(w,e)local a=pcall(function()e.Parent=game:GetService("CoreGui"):WaitForChild("RobloxGui",math.huge)end)if not a then local a=Instance.new("ScreenGui")task.spawn(w,a)a.ZIndexBehavior=Enum.ZIndexBehavior.Sibling;a.DisplayOrder=9e8;a.IgnoreGuiInset=true;a.Parent=game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui",math.huge)e.Parent=a end;e.AnchorPoint=Vector2.new(0.5,0.5)e.BackgroundColor3=Color3.fromRGB(60,60,60)e.BorderSizePixel=0;e.Position=UDim2.new(0.5,0,0.5,0)e.Size=UDim2.new(0,500,0,300)task.spawn(w,f)f.CornerRadius=UDim.new(0,4)f.Parent=e;task.spawn(w,g)g.BackgroundColor3=Color3.fromRGB(50,50,50)g.BorderSizePixel=0;g.Size=UDim2.new(1,0,0,30)g.ZIndex=2;g.Font=Enum.Font.Gotham;g.Text="Nanocore"g.TextColor3=Color3.fromRGB(255,255,255)g.TextSize=14;g.Parent=e;task.spawn(w,h)h.CornerRadius=UDim.new(0,4)h.Parent=g;task.spawn(w,i)i.BackgroundColor3=Color3.fromRGB(50,50,50)i.BorderSizePixel=0;i.ClipsDescendants=true;i.Position=UDim2.new(0,10,0,40)i.Size=UDim2.new(1,-20,1,-90)i.Parent=e;task.spawn(w,j)j.Active=true;j.BackgroundColor3=Color3.fromRGB(255,255,255)j.BackgroundTransparency=1;j.BorderSizePixel=0;j.Size=UDim2.new(1.04583335,-22,1,0)j.AutomaticCanvasSize=Enum.AutomaticSize.XY;j.CanvasSize=UDim2.new(0,0,0,0)j.ScrollBarThickness=6;j.Parent=i;task.spawn(w,k)k.AutomaticSize=Enum.AutomaticSize.XY;k.BackgroundColor3=Color3.fromRGB(255,255,255)k.BackgroundTransparency=1;k.BorderSizePixel=0;k.Size=UDim2.new(1,0,1,0)k.ClearTextOnFocus=false;k.Font=Enum.Font.Code;k.MultiLine=true;k.Text="print(\"Hello world!\")"k.TextColor3=Color3.fromRGB(255,255,255)k.TextSize=14;k.TextXAlignment=Enum.TextXAlignment.Left;k.TextYAlignment=Enum.TextYAlignment.Top;k.Parent=j;task.spawn(w,l)l.PaddingLeft=UDim.new(0,8)l.PaddingTop=UDim.new(0,5)l.Parent=k;task.spawn(w,m)m.AnchorPoint=Vector2.new(0,1)m.BackgroundColor3=Color3.fromRGB(255,255,255)m.BackgroundTransparency=1;m.BorderSizePixel=0;m.Position=UDim2.new(0,10,1,-10)m.Size=UDim2.new(1,-20,0,30)m.Parent=e;task.spawn(w,n)n.FillDirection=Enum.FillDirection.Horizontal;n.SortOrder=Enum.SortOrder.LayoutOrder;n.Padding=UDim.new(0,10)n.Parent=m;task.spawn(w,o)o.BackgroundColor3=Color3.fromRGB(50,50,50)o.BorderSizePixel=0;o.LayoutOrder=1;o.Size=UDim2.new(0,80,1,0)o.AutoButtonColor=false;o.Font=Enum.Font.Gotham;o.Text="Execute"o.TextColor3=Color3.fromRGB(255,255,255)o.TextSize=14;o.Parent=m;task.spawn(w,p)p.ApplyStrokeMode=Enum.ApplyStrokeMode.Border;p.Color=Color3.fromRGB(150,150,150)p.Transparency=1;p.Parent=o;task.spawn(w,q)q.CornerRadius=UDim.new(0,4)q.Parent=o;task.spawn(w,r)r.BackgroundColor3=Color3.fromRGB(50,50,50)r.BorderSizePixel=0;r.LayoutOrder=2;r.Size=UDim2.new(0,80,1,0)r.AutoButtonColor=false;r.Font=Enum.Font.Gotham;r.Text="Clear"r.TextColor3=Color3.fromRGB(255,255,255)r.TextSize=14;r.Parent=m;task.spawn(w,s)s.ApplyStrokeMode=Enum.ApplyStrokeMode.Border;s.Color=Color3.fromRGB(150,150,150)s.Transparency=1;s.Parent=r;task.spawn(w,t)t.CornerRadius=UDim.new(0,4)t.Parent=r;task.spawn(w,u)u.Color=Color3.fromRGB(120,120,120)u.Parent=e;task.spawn(x,e)local a=string.reverse(game:GetService("HttpService"):GenerateGUID(false))local e=false;pcall(function()getfenv().loadstring(string.format("getfenv()[\"%s\"] = 0",a))()if getfenv()[a]==0 then e=true;getfenv()[a]=nil end end)if not e then getfenv().loadstring=C end;a=nil;e=false;local a={Execute=function()xpcall(function()getfenv().loadstring(k.Text)()end,function(a)warn(a)end)end,Clear=function()k.Text=""end}for e,e in next,m:GetChildren()do if e:IsA("TextButton")then e.AutoButtonColor=false;local f=e:FindFirstChildWhichIsA("UIStroke")e.MouseEnter:Connect(function()f.Transparency=1;f.Color=c;v(f,b,{Transparency=0})end)e.MouseLeave:Connect(function()v(f,b,{Transparency=1})end)e.MouseButton1Down:Connect(function()v(f,b,{Color=d})end)e.MouseButton1Up:Connect(function()v(f,b,{Color=c})end)e.Activated:Connect(a[e.Text])end end